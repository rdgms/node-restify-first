{
  "name": "mongolia",
  "description": "Layer on top of the mongodb driver to implement data logic.",
  "version": "1.5.0",
  "author": {
    "name": "Pau Ramon",
    "email": "masylum@gmail.com"
  },
  "contributors": [
    {
      "name": "Pau Ramon",
      "email": "masylum@gmail.com"
    },
    {
      "name": "Josep M. Bach",
      "email": "josep.m.bach@gmail.com"
    }
  ],
  "keywords": [
    "mongo",
    "mongodb",
    "models",
    "database",
    "db"
  ],
  "main": "./index",
  "dependencies": {
    "mongodb": "=1.0.1",
    "funk": "1.0.1",
    "underscore": "1.1.6"
  },
  "devDependencies": {
    "mocha": "*",
    "testosterone": "1.2.0",
    "sinon": "1.3.4"
  },
  "repository": {
    "type": "git",
    "url": "http://github.com/masylum/mongolia.git"
  },
  "engines": {
    "node": ">= 0.4.0"
  },
  "readme": "    ooo        ooooo                                            oooo   o8o\n    `88.       .888'                                            `888   `\"'\n     888b     d'888   .ooooo.  ooo. .oo.    .oooooooo  .ooooo.   888  oooo   .oooo.\n     8 Y88. .P  888  d88' `88b `888P\"Y88b  888' `88b  d88' `88b  888  `888  `P  )88b\n     8  `888'   888  888   888  888   888  888   888  888   888  888   888   .oP\"888\n     8    Y     888  888   888  888   888  `88bod8P'  888   888  888   888  d8(  888\n    o8o        o888o `Y8bod8P' o888o o888o `8oooooo.  `Y8bod8P' o888o o888o `Y888\"\"8o\n                                           d\"     YD\n                                           \"Y88888P'\n\n\nMongolia is a thin layer that sits on top of the mongo native driver and helps you dealing with your data logic.\nMongolia is not an ORM. Models contains no state, just logic.\nMongolia contains no magic.\n\n## Install\n\n``` bash\nnpm install mongolia\n```\n\nMongolia contains two independent modules:\n\n  * `model`: An object representing a collection with some hooks of mongo calls.\n  * `validator`: An object that validates mongoDB documents and returns errors if found.\n\n# Model\n\nModels are attached to collections.\nModels don't map data from the db, they just define the logic.\n\n``` javascript\nvar USER = require('mongolia').model(db, 'users');\n```\n\n## mongo proxied collection commands\n\nCalls to the db are done using the method `mongo`.\n`mongo` proxies all the `collection` methods defined on the driver plus some custom methods.\n\nThis allows mongolia to extend the driver with extra functionalties:\n\n  * Namespacing: Allows you to filter the documents going and coming from the db.\n  * Mapping: Allows you to apply functions to the documents attributes going and coming from the db.\n  * Hooks: They are triggered before and after a call is done.\n\nThere are two APIs:\n\n`mongo('method[:namespace]', args)`\n\n and\n\n`mongo({method: method[, namespace: namespace, namespacing: false, mapping: false, hooks: false])`\n\nExample:\n``` javascript\nvar Db = require('mongodb/lib/mongodb/db').Db,\n    Server = require('mongodb/lib/mongodb/connection').Server,\n    db = new Db('blog', new Server('localhost', 27017, {auto_reconnect: true, native_parser: true}));\n\ndb.open(function () {\n  var User = require('./user.js')(db);\n\n  User.mongo('findOne', {name: 'foo'}, console.log);\n  User.mongo({method: 'insert', hooks: false}, {name: 'foo'}, console.log);\n});\n```\n\nAll the `collection` methods from the driver are supported and have a shortcut so you can use Mongolia\nlike the native driver (with the advantage of not having to ask for the collection):\n\nExample:\n``` javascript\n  User.findOne({name: 'foo'}, console.log);\n  User.insert({name: 'foo'}); // fire and forget\n});\n```\n\nIf you need more information on collection methods\nvisit the [driver](https://github.com/mongodb/node-mongodb-native) documentation\n\n### Custom mongo collection commands\n\nMongolia provides some useful commands that are not available using the driver.\n\n  * `findArray`: find that returns an array instead of a cursor.\n  * `mapReduceArray`: mapReduce that returns an array with the results.\n  * `mapReduceCursor`: mapReduce that returns a cursor.\n\n### Namespacing\n\nSecure your data access defining visibility namespaces.\n\nYou can namespace a call to the database by appending `:namespace` on\nyour proxied method.\n\nIf called without a namespace, the method will work ignoring the `namespace` directives.\n\nYou can `extend` other namespaces and `add` or `remove` some data visibility.\n\n``` javascript\nvar USER = require('mongolia').model(db, 'users');\n\nUSER.namespaces = {\n  public: ['account.email', 'account.name', '_id'],\n  private: {\n    extend: 'public',\n    add: ['password'],\n  },\n  accounting: {\n    extend: 'private',\n    add: ['credit_card_number'] // don't do this at home\n  }\n};\n\nUSER.mongo('insert:public', {account: {email: 'foo@bar.com'}, password: 'fleiba', credit_card_number: 123, is_active: true});\n// insert => {account: {email: 'foo@bar.com'}}\n\nUSER.validateAndUpdate({account: {email: 'foo@bar.com'}}, {'$set': {'account.email': 'super@mail.com', password: '123'}, {namespace: 'public'});\n// updates => {'$set': {'account.email': 'super@mail.com'}}\n\nUSER.mongo('findArray:public', {account: {email: 'foo@bar.com'}});\n// find => {account: {email: 'foo@bar.com', name: 'paco'}}\n\nUSER.mongo('findArray:accounting', {account: {email: 'foo@bar.com'}});\n// find => {account: {email: 'foo@bar.com', name: 'paco'}, password: 'fleiba', credit_card_number: 123}\n```\n\nUse this feature wisely to filter data coming from forms.\n\n### Mappings and type casting\n\nMongolia `maps` allows you to cast the data before is stored to the database.\nMongolia will apply the specified function for each attribute on the `maps` object.\n\nBy default we provide the map `_id -> ObjectId`, so you don't need to cast it.\n\n``` javascript\nvar USER = require('mongolia').model(db, 'users');\n\nUSER.maps = {\n  _id: ObjectID,\n  account: {\n    email: String,\n    name: function (val) {val.toUpperCase()}\n  },\n  password: String,\n  salt: String,\n  is_deleted: Boolean\n};\n\nUSER.mongo('insert', {email: 'foo@bar.com', password: 123, name: 'john', is_deleted: 'true'});\n// stored => {password: '123', name: 'JOHN', is_deleted: true}\n```\n\n### Hooks\n\nMongolia let you define some hooks on your models that will be triggered after a mongoDB command.\n\n  * `beforeInsert(documents, callback)`: triggered *before* an `insert`.\n  * `afterInsert(documents, callback)`: triggered *after* an `insert.\n\n  * `beforeUpdate(query, update, callback)`: triggered *before* an `update` or `findAndModify` command.\n  * `afterUpdate(query, update, callback)`: triggered *after* an `update` or `findAndModify` command.\n\n  * `beforeRemove(query, callback)`: triggered *before* a `remove` command.\n  * `afterRemove(query, callback)`: triggered *after* a `remove` command.\n\nExample:\n\n``` javascript\nvar COMMENT = require('mongolia').model(db, 'comments'),\n    Post = require('./post');\n\nCOMMENT.beforeInsert = function (documents, callback) {\n  documents.forEach(function (doc) {\n    doc.created_at = new Date();\n  });\n  callback(null, documents);\n};\n\nCOMMENT.atferInsert = function (documents, callback) {\n  documents.forEach(function (doc) {\n    Post(db).mongo('update', {_id: doc.post._id}, {'$inc': {num_posts: 1}}); // fire and forget\n  });\n  callback(null, documents);\n};\n\nUSER.mongo('insert', {email: 'foo@bar.com'});\n// stored => {email: 'foo@bar.com', created_at: Thu, 14 Jul 2011 12:13:39 GMT}\n// Post#num_posts is increased\n```\n\n## Embedded documents\n\nMongolia helps you to _denormalize_ your mongo collections.\n\n### getEmbeddedDocument\n\nFilters document following the `skeletons` attribute.\n\n    getEmbeddedDocument(name, object, scope [, dot_notation]);\n\nExample:\n\n``` javascript\nvar POST = require('mongolia').model(db, 'posts');\n\n// only embed the comment's _id, and title\nPOST.skeletons = {\n  comment: ['_id', 'title', 'post.name']\n};\n\nvar comment = {'_id': 1, title: 'foo', body: 'Lorem ipsum', post: {_id: 1, name: 'bar'}}\nconsole.log(Post(db).getEmbeddedDocument('comment', comment));\n// outputs => {'_id': 1, title: 'foo', post: {name: 'bar'}};\n\nconsole.log(Post(db).getEmbeddedDocument('comment', comment, 'post'));\n// outputs => {post: {'_id': 1, title: 'foo', post: {name: 'bar'}}};\n\nconsole.log(Post(db).getEmbeddedDocument('comment', comment, 'posts', true));\n// outputs => {'posts._id': 1, 'posts.title': 'foo', 'posts.post.name': 'bar'};\n```\n\n### updateEmbeddedDocument\n\nUpdates an embed object following the `skeletons` directive.\n\n``` javascript\nModel.updateEmbeddedDocument(query, document_name, document[, options, callback]);\n```\n\nExample:\n\n``` javascript\nmodule.exports = function (db) {\n  var USER = require('mongolia').model(db, 'users');\n\n  // After updating a user, we want to update denormalized Post.author foreach post\n  USER.afterUpdate = function (query, update, callback) {\n    Post(db).updateEmbeddedDocument({_id: query._id}, 'author', update, {upsert: false}, callback);\n  };\n\n  return USER;\n};\n```\n\n### pushEmbeddedDocument\n\nPushes an embedded document following the `skeletons` directive.\n\n``` javascript\nModel.pushEmbeddedDocument(query, data, name[, options, callback]);\n```\n\nExample:\n\n``` javascript\nmodule.exports = function (db) {\n  var POST = require('mongolia')(db, 'posts');\n\n  // After inserting a post, we want to push it to `users.posts[]`\n  POST.afterInsert = function (documents, callback) {\n    User(db).pushEmbeddedDocument({_id: documents[0].author._id}, 'posts', document, callback);\n  };\n\n  return POST;\n}\n```\n\n## Create and update using validations\n\nMongolia provides two methods that allow you to create and update using the `validator`.\n\n``` javascript\nModel.validateAndInsert(document[, options, callback(error, validator)]);\nModel.validateAndUpdate(document, update[, options, callback(error, validator)]);\n```\n\nTo scope the insert/update within a namespace, use `options.namespace`.\n\nIn order to validate an insertion/update, the model have to implement a `validate` function on your model.\n\n``` javascript\nvalidate(query, update, callback);\n```\n\nExample:\n\n``` javascript\n// post.js\nmodule.exports = function (db) {\n  var POST = require('mongolia').model(db, 'posts');\n\n  POST.validate = function (query, update, callback) {\n    var validator = require('mongolia').validator(query, update);\n\n    validator.validateRegex({\n      title: [validator.regex.title, 'Incorrect title'],\n      body: [/.{4,200}/, 'Incorrect body'],\n    });\n\n    if (!update.body === 'Lorem ipsum') {\n      validator.addError('body', 'You can be a little bit more creative');\n    }\n\n    callback(null, validator);\n  }\n\n  return POST;\n};\n\n// app.js\nvar Post = require('./post.js');\n\nPost(db).validateAndInsert(\n  {title: 'This is a post', body: 'Lorem ipsum'},\n  function (error, validator) {\n    if (validator.hasErrors()) {\n      console.log(validator.errors);\n    } else {\n      console.log(validator.updated_document);\n    }\n  }\n);\n```\n\n# Validator\n\nMongolia validator accepts a document and an update.\n\nIf you are validating an insert, the document will be an empty object `{}` and the update\nthe document you are inserting.\n\nMongolia will resolve the update client side exposing a `updated_document`.\n\n``` javascript\nvar validator = require('mongolia').validator({foo: 1}, {'$inc': {foo: 1}});\n\nif (validator.updated_document.foo > 1) {\n  validator.addError('foo', 'foo must be ONE');\n}\nconsole.log(validator.hasError('foo')); // => true\n```\n\nAll the methods listed below accept `dot_notation`.\n\n## API\n\nReturns true if the validator is handling an updateInstance operation.\n\n``` javascript\nisUpdating()\n```\n\nReturns true if the validator is handling an createInstance operation.\n\n``` javascript\nisInserting()\n```\n\nReturns true if the attributed changed\n\n``` javascript\nattrChanged(attr)\n```\n\nAdds an error to your validator. Accept dot notation to add nested errors.\n\n``` javascript\naddError(field, value)\n```\n\nReturns true if the attributed failed a validation. Accept dot notation to check nested errors.\n\n``` javascript\nhasError(field)\n```\n\nReturns true if any attributed failed a validation\n\n``` javascript\nhasErrors()\n```\n\nIt fills your validator with errors if any of the elements are empty\n\n``` javascript\nvalidateExistence({\n  attr: 'Error message'\n, attr: ...\n})\n```\n\nIt fills your validator with errors if any of the elements fail the regex\n\n``` javascript\nvalidateRegex({\n  attr: [/regex/, 'Error message']\n, attr: ...\n})\n```\n\nIt fills your validator with errors if any of the elements fail the confirmation (good for passwords)\n\n``` javascript\nvalidateConfirmation({\n  attr: ['confirmation_attr', 'Error message']\n, attr: ...\n})\n```\n\nIt fills your validator with errors if any of the queries fail (good to avoid duplicated data)\n\n``` javascript\nvalidateQuery({\n  attr: [Model, query, false, 'Error message']\n, attr: ...\n}, callback)\n```\n\nExample using some of the validator features:\n\n``` javascript\nvar User = function (db) {\n  var USER = require('mongolia').model(db, 'users');\n\n  USER.validate = function (document, update, callback) {\n    var validator = require('mongolia').validator(document, update)\n      , updated_document = validator.updated_document;\n\n    validator.validateRegex({\n      name: [validator.regex.username, 'Incorrect name'],\n      email: [validator.regex.email, 'Incorrect email'],\n      password: [validator.regex.password, 'Incorrect password'],\n      description: [validator.regex.description, 'Incorrect description']\n    });\n\n    if (validator.attrChanged('password')) {\n      validator.validateConfirmation({\n        'password': ['password_confirmation', 'Passwords must match']\n      });\n    }\n\n    if (!updated_document.tags || updated_document.tags.length <= 0) {\n      validator.addError('tags', 'Select at least one tag');\n    }\n\n    validator.validateQuery({\n      email: [\n        this\n      , {_id: {'$not': document._id}, email: updated_document.email}\n      , false\n      , 'There is already a user with this email'\n      ]\n    }, function () {\n      callback(null, validator);\n    });\n  }\n\n  return USER;\n};\n```\n\n## Tests\n\nMongolia is fully tested using [mocha](http://github.com/visionmedia/mocha)\nTo run the tests use:\n\n```bash\nmake\n```\n\n## Example\n\nMongolia has a fully working blog example on the `example` folder.\n\n## Contributors\n\nIn no specific order.\n\n  * Josep M. Bach ([txus](http://github.com/txus))\n  * Pau Ramon ([masylum](http://github.com/masylum))\n\n## License\n\n(The MIT License)\n\nCopyright (c) 2010-2011 Pau Ramon Revilla &lt;masylum@gmail.com&gt;\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n'Software'), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n",
  "_id": "mongolia@1.5.0",
  "_from": "mongolia"
}
