{
  "name": "funk",
  "description": "Asynchronous functions made funky!",
  "version": "1.0.1",
  "main": "./lib/funk",
  "author": {
    "name": "Pau Ramon",
    "email": "masylum@gmail.com"
  },
  "repository": {
    "type": "git",
    "url": "http://github.com/masylum/funk.git"
  },
  "engines": {
    "node": ">= 0.2.0"
  },
  "readme": "     ,dPYb,                           ,dPYb,\n     IP'`Yb                           IP'`Yb\n     I8  8I                           I8  8I\n     I8  8'                           I8  8bgg,\n     I8 dP  gg      gg   ,ggg,,ggg,   I8 dP\" \"8\n     I8dP   I8      8I  ,8\" \"8P\" \"8,  I8d8bggP\"\n     I8P    I8,    ,8I  I8   8I   8I  I8P' \"Yb,\n    ,d8b,_ ,d8b,  ,d8b,,dP   8I   Yb,,d8    `Yb,\n    PI8\"8888P'\"Y88P\"`Y88P'   8I   `Y888P      Y8\n     I8 `8,\n     I8  `8,\n     I8   8I\n     I8   8I\n     I8, ,8'\n      \"Y8P'\n\n\nAsynchronous functions made funky!\n\n## What the funk?\n\n_funk_ will not:\n\n- Make you code asynchronous as if it where synchrnous.\n- Add overhead to your application.\n- _funk_ and revolution will not be televised.\n\n_funk_ will:\n\n- Make your asynchronous code easier to code.\n- Make your code more readable.\n- _funk_ will make your sexual life more interesing. Try some James Brown when you get laid.\n\n## Instalation\n\n    npm install funk\n\n## API\n\n_funk_ usage is really simple. You don't need to learn DSLs or weird system,\njust wrap your callbacks and let the groove do the rest.\n\n- `set(name, value)`: Save results that will then be recovered o the `serial` or `parallel` callback.\n- `get(name)`: Retrieve results previously saved.\n- `add(function)`: Adds the function to funk.\n- `nothing()`: Adds the function to funk without setting any result.\n- `result(name, value)`: Adds the function to funk and sets the value.\n- `parallel(callback)`: Will run all the added functions in parallel and call _callback_ when all are done. `this` holds all the results setted with `set`.\n- `serial(callback)`: Will run all the added functions in serial and call _callback_ when all are done. `this` holds all the results setted with `set`.\n\n## Parallel example\n\nFunk is really useful when you need to do something after a bunch of asynchronous callbacks are called.\n\n    var funk = require('funk')(),\n        assert = require('assert'),\n        fs = require('fs');\n\n    funk.set('results', []);\n\n    fs.readFile(\"dance_moves/james_brown.txt\", funk.add(function (er, data) {\n      this.moves.push(data);\n    }));\n\n    fs.readFile(\"dance_moves/jackson_5.txt\", funk.add(function (er, data) {\n      this.moves.push(data);\n    }));\n\n    setTimeout(funk.result('foo', 'bar'), 200);\n\n    funk.parallel(function(){\n      assert.equals(this.moves.length, 2);\n      assert.equals(this.foo, 'bar');\n      assert.equals(funk.get('foo'), 'bar');\n      console.log('This is funktastic!');\n    });\n\n## Serial example\n\nDealing with nested callbacks can sometimes be a PITA. _funk_ will ease the pain.\n\n    var funk = require('funk')(),\n        assert = require('assert'),\n        order = 0;\n\n    setTimeout(funk.add(function () {\n      order++;\n      funk.set('order_first', order);\n    }), 200);\n\n    setTimeout(funk.nothing(), 100);\n\n    setTimeout(funk.add(function () {\n      order++;\n      this.order_second = order;\n    }), 5);\n\n    funk.serial(function(){\n      assert.equals(this.order_first, 1);\n      assert.equals(this.order_second, 2);\n      console.log('Funkinbelievable!');\n    });\n\n## Tests\n\n_funk_ is fully tested using [testosterone](https://github.com/masylum/testosterone).\n\n    npm install testosterone\n\nIn order to run the tests type:\n\n    make\n",
  "_id": "funk@1.0.1",
  "_from": "funk@1.0.1"
}
